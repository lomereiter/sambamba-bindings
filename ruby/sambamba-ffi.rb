# Generated by ffi-gen. Please do not change this file by hand.

module SambambaFFI
  def self.attach_function(name, *_)
    begin; super; rescue FFI::NotFoundError => e
      (class << self; self; end).class_eval { define_method(name) { |*_| raise e } }
    end
  end
  
  # (Not documented)
  # 
  # @method attach()
  # @return [nil] 
  # @scope class
  attach_function :attach, :attach, [], :void
  
  # must be called to initialize D runtime
  # 
  # @method detach()
  # @return [nil] 
  # @scope class
  attach_function :detach, :detach, [], :void
  
  # (Not documented)
  # 
  # @method memcpy(dest, src, n)
  # @param [FFI::Pointer(*Void)] dest 
  # @param [FFI::Pointer(*Void)] src 
  # @param [Integer] n 
  # @return [FFI::Pointer(*Void)] 
  # @scope class
  attach_function :memcpy, :memcpy, [:pointer, :pointer, :ulong], :pointer
  
  # (Not documented)
  # 
  # @method free(ptr)
  # @param [FFI::Pointer(*Void)] ptr 
  # @return [nil] 
  # @scope class
  attach_function :free, :free, [:pointer], :void
  
  # (Not documented)
  # 
  # @method d_free(void)
  # @param [FFI::Pointer(*Void)] void 
  # @return [nil] 
  # @scope class
  attach_function :d_free, :d_free, [:pointer], :void
  
  # frees the pointer and notifies D garbage collector
  # 
  # @method last_error_message()
  # @return [String] 
  # @scope class
  attach_function :last_error_message, :last_error_message, [], :string
  
  # In D, the array layout is as follows
  # 
  # = Fields:
  # :buf ::
  #   (String) 
  # :len ::
  #   (Integer) 
  class DstringS < FFI::Struct
    layout :buf, :string,
           :len, :ulong
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :buf ::
  #   (FFI::Pointer(*Int8T)) 
  # :len ::
  #   (Integer) 
  class Aint8S < FFI::Struct
    layout :buf, :pointer,
           :len, :ulong
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :buf ::
  #   (FFI::Pointer(*Uint8T)) 
  # :len ::
  #   (Integer) 
  class Auint8S < FFI::Struct
    layout :buf, :pointer,
           :len, :ulong
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :buf ::
  #   (FFI::Pointer(*Int16T)) 
  # :len ::
  #   (Integer) 
  class Aint16S < FFI::Struct
    layout :buf, :pointer,
           :len, :ulong
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :buf ::
  #   (FFI::Pointer(*Uint16T)) 
  # :len ::
  #   (Integer) 
  class Auint16S < FFI::Struct
    layout :buf, :pointer,
           :len, :ulong
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :buf ::
  #   (FFI::Pointer(*Int32T)) 
  # :len ::
  #   (Integer) 
  class Aint32S < FFI::Struct
    layout :buf, :pointer,
           :len, :ulong
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :buf ::
  #   (FFI::Pointer(*Uint32T)) 
  # :len ::
  #   (Integer) 
  class Auint32S < FFI::Struct
    layout :buf, :pointer,
           :len, :ulong
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :buf ::
  #   (FFI::Pointer(*Float)) 
  # :len ::
  #   (Integer) 
  class AfloatS < FFI::Struct
    layout :buf, :pointer,
           :len, :ulong
  end
  
  # BAM reader object
  # 
  # = Fields:
  # :len ::
  #   (Integer) length of raw data
  # :buf ::
  #   (FFI::Pointer(*Uint8T)) raw data
  # :reader ::
  #   (FFI::Pointer(BamReaderT)) parent reader
  class BamReadS < FFI::Struct
    layout :len, :ulong,
           :buf, :pointer,
           :reader, :pointer
  end
  
  # For now, the interface for SAM header is very limited:
  #    1) get header from a BAM file
  #    2) get its text representation
  #    3) create new header from text
  # 
  #    (anyway, text manipulation is not a big deal in most dynamic languages.)
  # 
  # @method bam_reader_header(bam_reader_t)
  # @param [FFI::Pointer(BamReaderT)] bam_reader_t 
  # @return [FFI::Pointer(SamHeaderT)] 
  # @scope class
  attach_function :bam_reader_header, :bam_reader_header, [:pointer], :pointer
  
  # (Not documented)
  # 
  # @method df_sam_header_text(sam_header_t)
  # @param [FFI::Pointer(SamHeaderT)] sam_header_t 
  # @return [DstringS] 
  # @scope class
  attach_function :df_sam_header_text, :df_sam_header_text, [:pointer], DstringS
  
  # (Not documented)
  # 
  # @method sam_header_new(header_text)
  # @param [String] header_text 
  # @return [FFI::Pointer(SamHeaderT)] 
  # @scope class
  attach_function :sam_header_new, :sam_header_new, [:string], :pointer
  
  # callback that returns next BAM read or NULL to stop iteration,
  #    can be passed to this function and made into a D range
  # 
  # @method bam_read_range_adapter_new(next_func_t)
  # @param [FFI::Pointer(NextFuncT)] next_func_t 
  # @return [FFI::Pointer(BamReadRangeT)] 
  # @scope class
  attach_function :bam_read_range_adapter_new, :bam_read_range_adapter_new, [:pointer], :pointer
  
  # Iteration is meant to be done as follows: 
  #    1) get the size of raw data using bam_readrange_front_alloc_size 
  #    2) if the size is 0, the range is empty; stop iteration 
  #    3) otherwise, allocate chunk of memory in the target language
  #       and pass it to bam_readrange_front_copy_into_and_pop_front.
  #       It will fill the buffer, return bam_reader_t object, and
  #       move to the next read.
  #    4) create new bam_read_t object and fill its fields
  #       (length of raw data, pointer to raw data, and reader).
  #       All its memory is now managed by _target_ language, not D.
  #    
  #    This looks quite cumbersome, and it surely is, but:
  #    1) If the memory was managed by D, finalizers would be needed
  #       in order to free the memory, which is a huge performance hit.
  #    2) Only two FFI calls per read make for less overhead.
  # 
  # @method bam_readrange_front_alloc_size(bam_read_range_t)
  # @param [FFI::Pointer(BamReadRangeT)] bam_read_range_t 
  # @return [Integer] 
  # @scope class
  attach_function :bam_readrange_front_alloc_size, :bam_readrange_front_alloc_size, [:pointer], :ulong
  
  # (Not documented)
  # 
  # @method bam_readrange_front_copy_into_and_pop_front(bam_read_range_t, buffer)
  # @param [FFI::Pointer(BamReadRangeT)] bam_read_range_t 
  # @param [String] buffer 
  # @return [FFI::Pointer(BamReaderT)] 
  # @scope class
  attach_function :bam_readrange_front_copy_into_and_pop_front, :bam_readrange_front_copy_into_and_pop_front, [:pointer, :buffer_out], :pointer
  
  # ------------------ Reference sequence information ------------------------
  # 
  # = Fields:
  # :name_len ::
  #   (Integer) length of reference sequence name
  # :name_buf ::
  #   (String) reference sequence name (zero-terminated)
  # :length ::
  #   (Integer) length of reference sequence
  class ReferenceInfoS < FFI::Struct
    layout :name_len, :ulong,
           :name_buf, :string,
           :length, :int
  end
  
  # information about single reference sequence
  # 
  # = Fields:
  # :buf ::
  #   (ReferenceInfoS) 
  # :len ::
  #   (Integer) 
  class AreferenceInfoS < FFI::Struct
    layout :buf, ReferenceInfoS,
           :len, :ulong
  end
  
  # array containing reference sequence information
  # 
  # = Fields:
  # :buf ::
  #   (FFI::Pointer(*Uint8T)) 
  # :len ::
  #   (Integer) 
  class BufferS < FFI::Struct
    layout :buf, :pointer,
           :len, :ulong
  end
  
  # D task pool
  # 
  # @method task_pool_new(n_threads)
  # @param [Integer] n_threads 
  # @return [FFI::Pointer(TaskPoolT)] 
  # @scope class
  attach_function :task_pool_new, :task_pool_new, [:uint], :pointer
  
  # MUST be called to terminate the threads
  # 
  # @method task_pool_finish(task_pool_t)
  # @param [FFI::Pointer(TaskPoolT)] task_pool_t 
  # @return [Integer] 
  # @scope class
  attach_function :task_pool_finish, :task_pool_finish, [:pointer], :int
  
  # constructors
  # 
  # @method bam_reader_new(filename)
  # @param [String] filename 
  # @return [FFI::Pointer(BamReaderT)] 
  # @scope class
  attach_function :bam_reader_new, :bam_reader_new, [:string], :pointer
  
  # (Not documented)
  # 
  # @method bam_reader_new2(string, task_pool_t)
  # @param [String] string 
  # @param [FFI::Pointer(TaskPoolT)] task_pool_t 
  # @return [FFI::Pointer(BamReaderT)] 
  # @scope class
  attach_function :bam_reader_new2, :bam_reader_new2, [:string, :pointer], :pointer
  
  # zero-terminated filename
  # 
  # @method bam_reader_filename(bam_reader_t)
  # @param [FFI::Pointer(BamReaderT)] bam_reader_t 
  # @return [String] 
  # @scope class
  attach_function :bam_reader_filename, :bam_reader_filename, [:pointer], :string
  
  # create BAI index file (unless it already exists and !force)
  # 
  # @method bam_reader_create_index(bam_reader_t, force)
  # @param [FFI::Pointer(BamReaderT)] bam_reader_t 
  # @param [Integer] force 
  # @return [nil] 
  # @scope class
  attach_function :bam_reader_create_index, :bam_reader_create_index, [:pointer, :int], :void
  
  # all reads in the BAM file
  # 
  # @method bam_reader_reads(bam_reader_t)
  # @param [FFI::Pointer(BamReaderT)] bam_reader_t 
  # @return [FFI::Pointer(BamReadRangeT)] 
  # @scope class
  attach_function :bam_reader_reads, :bam_reader_reads, [:pointer], :pointer
  
  # fetch reads overlapping a region
  # 
  # @method bam_reader_fetch(bam_reader_t, refname, from, to)
  # @param [FFI::Pointer(BamReaderT)] bam_reader_t 
  # @param [String] refname 
  # @param [Integer] from 
  # @param [Integer] to 
  # @return [FFI::Pointer(BamReadRangeT)] 
  # @scope class
  attach_function :bam_reader_fetch, :bam_reader_fetch, [:pointer, :string, :uint, :uint], :pointer
  
  # reference sequences presented in the file
  # 
  # @method bam_reader_references(bam_reader_t)
  # @param [FFI::Pointer(BamReaderT)] bam_reader_t 
  # @return [AreferenceInfoS] 
  # @scope class
  attach_function :bam_reader_references, :bam_reader_references, [:pointer], AreferenceInfoS.by_value
  
  # get SAM representation of the read
  # 
  # @method df_bam_read_to_sam(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [DstringS] 
  # @scope class
  attach_function :df_bam_read_to_sam, :df_bam_read_to_sam, [BamReadS], DstringS
  
  # '+' or '-'
  # 
  # @method bam_read_strand(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_strand, :bam_read_strand, [BamReadS], :char
  
  # (Not documented)
  # 
  # @method bam_read_mate_strand(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_mate_strand, :bam_read_mate_strand, [BamReadS], :char
  
  # character must be checked in the target language
  # 
  # @method bam_read_set_strand(bam_read_s, char_s)
  # @param [BamReadS] bam_read_s 
  # @param [Integer] char_s 
  # @return [nil] 
  # @scope class
  attach_function :bam_read_set_strand, :bam_read_set_strand, [BamReadS, :char], :void
  
  # (Not documented)
  # 
  # @method bam_read_set_mate_strand(bam_read_s, char_s)
  # @param [BamReadS] bam_read_s 
  # @param [Integer] char_s 
  # @return [nil] 
  # @scope class
  attach_function :bam_read_set_mate_strand, :bam_read_set_mate_strand, [BamReadS, :char], :void
  
  # read sequence length (bp)
  # 
  # @method bam_read_sequence_length(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_sequence_length, :bam_read_sequence_length, [BamReadS], :ulong
  
  # copy the sequence into a preallocated buffer 
  #   (get its size using the above function, and add one for the '\0')
  # 
  # @method bam_read_copy_sequence(bam_read_s, buf)
  # @param [BamReadS] bam_read_s 
  # @param [String] buf 
  # @return [nil] 
  # @scope class
  attach_function :bam_read_copy_sequence, :bam_read_copy_sequence, [BamReadS, :string], :void
  
  # automatically resizes the qualities to the length of the sequence
  #    and sets them all to 0xFF (i.e. missing)
  # 
  # @method df_bam_read_set_sequence(bam_read_s, new_sequence)
  # @param [BamReadS] bam_read_s 
  # @param [String] new_sequence 
  # @return [BufferS] 
  # @scope class
  attach_function :df_bam_read_set_sequence, :df_bam_read_set_sequence, [BamReadS, :string], BufferS
  
  # (Not documented)
  # 
  # @method bam_read_base_qualities(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [Aint8S] 
  # @scope class
  attach_function :bam_read_base_qualities, :bam_read_base_qualities, [BamReadS], Aint8S.by_value
  
  # (Not documented)
  # 
  # @method df_bam_read_set_base_qualities(bam_read_s, buf, len)
  # @param [BamReadS] bam_read_s 
  # @param [FFI::Pointer(*Int8T)] buf 
  # @param [Integer] len 
  # @return [BufferS] 
  # @scope class
  attach_function :df_bam_read_set_base_qualities, :df_bam_read_set_base_qualities, [BamReadS, :pointer, :ulong], BufferS
  
  # (Not documented)
  # 
  # @method bam_read_name(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [DstringS] 
  # @scope class
  attach_function :bam_read_name, :bam_read_name, [BamReadS], DstringS.by_value
  
  # (Not documented)
  # 
  # @method df_bam_read_set_name(bam_read_s, new_name)
  # @param [BamReadS] bam_read_s 
  # @param [String] new_name 
  # @return [BufferS] 
  # @scope class
  attach_function :df_bam_read_set_name, :df_bam_read_set_name, [BamReadS, :string], BufferS
  
  # (Not documented)
  # 
  # @method bam_read_mapping_quality(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_mapping_quality, :bam_read_mapping_quality, [BamReadS], :char
  
  # -1 if missing
  # 
  # @method bam_read_set_mapping_quality(bam_read_s, s_char)
  # @param [BamReadS] bam_read_s 
  # @param [Integer] s_char 
  # @return [nil] 
  # @scope class
  attach_function :bam_read_set_mapping_quality, :bam_read_set_mapping_quality, [BamReadS, :char], :void
  
  # (Not documented)
  # 
  # @method bam_read_ref_id(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_ref_id, :bam_read_ref_id, [BamReadS], :int
  
  # (Not documented)
  # 
  # @method bam_read_set_ref_id(bam_read_s, int)
  # @param [BamReadS] bam_read_s 
  # @param [Integer] int 
  # @return [nil] 
  # @scope class
  attach_function :bam_read_set_ref_id, :bam_read_set_ref_id, [BamReadS, :int], :void
  
  # (Not documented)
  # 
  # @method bam_read_reference_name(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [String] 
  # @scope class
  attach_function :bam_read_reference_name, :bam_read_reference_name, [BamReadS], :string
  
  # zero-based position on the reference
  # 
  # @method bam_read_position(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_position, :bam_read_position, [BamReadS], :int
  
  # (Not documented)
  # 
  # @method bam_read_set_position(bam_read_s, int)
  # @param [BamReadS] bam_read_s 
  # @param [Integer] int 
  # @return [nil] 
  # @scope class
  attach_function :bam_read_set_position, :bam_read_set_position, [BamReadS, :int], :void
  
  # (Not documented)
  # 
  # @method bam_read_mate_ref_id(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_mate_ref_id, :bam_read_mate_ref_id, [BamReadS], :int
  
  # (Not documented)
  # 
  # @method bam_read_set_mate_ref_id(bam_read_s, int)
  # @param [BamReadS] bam_read_s 
  # @param [Integer] int 
  # @return [nil] 
  # @scope class
  attach_function :bam_read_set_mate_ref_id, :bam_read_set_mate_ref_id, [BamReadS, :int], :void
  
  # (Not documented)
  # 
  # @method bam_read_mate_position(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_mate_position, :bam_read_mate_position, [BamReadS], :int
  
  # zero-based
  # 
  # @method bam_read_set_mate_position(bam_read_s, int)
  # @param [BamReadS] bam_read_s 
  # @param [Integer] int 
  # @return [nil] 
  # @scope class
  attach_function :bam_read_set_mate_position, :bam_read_set_mate_position, [BamReadS, :int], :void
  
  # (Not documented)
  # 
  # @method bam_read_flag(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_flag, :bam_read_flag, [BamReadS], :ushort
  
  # (Not documented)
  # 
  # @method bam_read_set_flag(bam_read_s, u_short)
  # @param [BamReadS] bam_read_s 
  # @param [Integer] u_short 
  # @return [nil] 
  # @scope class
  attach_function :bam_read_set_flag, :bam_read_set_flag, [BamReadS, :ushort], :void
  
  # (Not documented)
  # 
  # @method bam_read_template_length(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_template_length, :bam_read_template_length, [BamReadS], :int
  
  # (Not documented)
  # 
  # @method bam_read_set_template_length(bam_read_s, int)
  # @param [BamReadS] bam_read_s 
  # @param [Integer] int 
  # @return [nil] 
  # @scope class
  attach_function :bam_read_set_template_length, :bam_read_set_template_length, [BamReadS, :int], :void
  
  # (Not documented)
  # 
  # = Fields:
  # :buf ::
  #   (FFI::Pointer(*Uint32T)) 
  # :len ::
  #   (Integer) 
  class CigarS < FFI::Struct
    layout :buf, :pointer,
           :len, :ulong
  end
  
  # (Not documented)
  # 
  # @method bam_cigar_operation_length(u_int)
  # @param [Integer] u_int 
  # @return [Integer] 
  # @scope class
  attach_function :bam_cigar_operation_length, :bam_cigar_operation_length, [:uint], :uint
  
  # (Not documented)
  # 
  # @method bam_cigar_operation_type(u_int)
  # @param [Integer] u_int 
  # @return [Integer] 
  # @scope class
  attach_function :bam_cigar_operation_type, :bam_cigar_operation_type, [:uint], :char
  
  # MIDNSHP=X
  # 
  # @method bam_cigar_operation_consumes_ref(u_int)
  # @param [Integer] u_int 
  # @return [Integer] 
  # @scope class
  attach_function :bam_cigar_operation_consumes_ref, :bam_cigar_operation_consumes_ref, [:uint], :int
  
  # types M=XDN
  # 
  # @method bam_cigar_operation_consumes_query(u_int)
  # @param [Integer] u_int 
  # @return [Integer] 
  # @scope class
  attach_function :bam_cigar_operation_consumes_query, :bam_cigar_operation_consumes_query, [:uint], :int
  
  # types M=XIS
  # 
  # @method bam_cigar_operation_consumes_both(u_int)
  # @param [Integer] u_int 
  # @return [Integer] 
  # @scope class
  attach_function :bam_cigar_operation_consumes_both, :bam_cigar_operation_consumes_both, [:uint], :int
  
  # types M=X
  # 
  # @method bam_read_cigar(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [CigarS] 
  # @scope class
  attach_function :bam_read_cigar, :bam_read_cigar, [BamReadS], CigarS.by_value
  
  # (Not documented)
  # 
  # @method f_bam_read_extended_cigar(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [CigarS] 
  # @scope class
  attach_function :f_bam_read_extended_cigar, :f_bam_read_extended_cigar, [BamReadS], CigarS.by_value
  
  # (Not documented)
  # 
  # @method df_bam_read_set_cigar(bam_read_s, buf, len)
  # @param [BamReadS] bam_read_s 
  # @param [FFI::Pointer(*Uint32T)] buf 
  # @param [Integer] len 
  # @return [BufferS] 
  # @scope class
  attach_function :df_bam_read_set_cigar, :df_bam_read_set_cigar, [BamReadS, :pointer, :ulong], BufferS
  
  # read flags
  # 
  # @method bam_read_is_paired(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_is_paired, :bam_read_is_paired, [BamReadS], :int
  
  # (Not documented)
  # 
  # @method bam_read_proper_pair(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_proper_pair, :bam_read_proper_pair, [BamReadS], :int
  
  # (Not documented)
  # 
  # @method bam_read_is_unmapped(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_is_unmapped, :bam_read_is_unmapped, [BamReadS], :int
  
  # (Not documented)
  # 
  # @method bam_read_mate_is_unmapped(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_mate_is_unmapped, :bam_read_mate_is_unmapped, [BamReadS], :int
  
  # (Not documented)
  # 
  # @method bam_read_is_reverse_strand(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_is_reverse_strand, :bam_read_is_reverse_strand, [BamReadS], :int
  
  # (Not documented)
  # 
  # @method bam_read_mate_is_reverse_strand(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_mate_is_reverse_strand, :bam_read_mate_is_reverse_strand, [BamReadS], :int
  
  # (Not documented)
  # 
  # @method bam_read_is_first_of_pair(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_is_first_of_pair, :bam_read_is_first_of_pair, [BamReadS], :int
  
  # (Not documented)
  # 
  # @method bam_read_is_second_of_pair(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_is_second_of_pair, :bam_read_is_second_of_pair, [BamReadS], :int
  
  # (Not documented)
  # 
  # @method bam_read_is_secondary_alignment(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_is_secondary_alignment, :bam_read_is_secondary_alignment, [BamReadS], :int
  
  # (Not documented)
  # 
  # @method bam_read_failed_quality_control(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_failed_quality_control, :bam_read_failed_quality_control, [BamReadS], :int
  
  # (Not documented)
  # 
  # @method bam_read_is_duplicate(bam_read_s)
  # @param [BamReadS] bam_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_is_duplicate, :bam_read_is_duplicate, [BamReadS], :int
  
  # (Not documented)
  # 
  # @method bam_read_set_is_paired(bam_read_s, int)
  # @param [BamReadS] bam_read_s 
  # @param [Integer] int 
  # @return [nil] 
  # @scope class
  attach_function :bam_read_set_is_paired, :bam_read_set_is_paired, [BamReadS, :int], :void
  
  # (Not documented)
  # 
  # @method bam_read_set_proper_pair(bam_read_s, int)
  # @param [BamReadS] bam_read_s 
  # @param [Integer] int 
  # @return [nil] 
  # @scope class
  attach_function :bam_read_set_proper_pair, :bam_read_set_proper_pair, [BamReadS, :int], :void
  
  # (Not documented)
  # 
  # @method bam_read_set_is_unmapped(bam_read_s, int)
  # @param [BamReadS] bam_read_s 
  # @param [Integer] int 
  # @return [nil] 
  # @scope class
  attach_function :bam_read_set_is_unmapped, :bam_read_set_is_unmapped, [BamReadS, :int], :void
  
  # (Not documented)
  # 
  # @method bam_read_set_mate_is_unmapped(bam_read_s, int)
  # @param [BamReadS] bam_read_s 
  # @param [Integer] int 
  # @return [nil] 
  # @scope class
  attach_function :bam_read_set_mate_is_unmapped, :bam_read_set_mate_is_unmapped, [BamReadS, :int], :void
  
  # (Not documented)
  # 
  # @method bam_read_set_is_reverse_strand(bam_read_s, int)
  # @param [BamReadS] bam_read_s 
  # @param [Integer] int 
  # @return [nil] 
  # @scope class
  attach_function :bam_read_set_is_reverse_strand, :bam_read_set_is_reverse_strand, [BamReadS, :int], :void
  
  # (Not documented)
  # 
  # @method bam_read_set_mate_is_reverse_strand(bam_read_s, int)
  # @param [BamReadS] bam_read_s 
  # @param [Integer] int 
  # @return [nil] 
  # @scope class
  attach_function :bam_read_set_mate_is_reverse_strand, :bam_read_set_mate_is_reverse_strand, [BamReadS, :int], :void
  
  # (Not documented)
  # 
  # @method bam_read_set_is_first_of_pair(bam_read_s, int)
  # @param [BamReadS] bam_read_s 
  # @param [Integer] int 
  # @return [nil] 
  # @scope class
  attach_function :bam_read_set_is_first_of_pair, :bam_read_set_is_first_of_pair, [BamReadS, :int], :void
  
  # (Not documented)
  # 
  # @method bam_read_set_is_second_of_pair(bam_read_s, int)
  # @param [BamReadS] bam_read_s 
  # @param [Integer] int 
  # @return [nil] 
  # @scope class
  attach_function :bam_read_set_is_second_of_pair, :bam_read_set_is_second_of_pair, [BamReadS, :int], :void
  
  # (Not documented)
  # 
  # @method bam_read_set_is_secondary_alignment(bam_read_s, int)
  # @param [BamReadS] bam_read_s 
  # @param [Integer] int 
  # @return [nil] 
  # @scope class
  attach_function :bam_read_set_is_secondary_alignment, :bam_read_set_is_secondary_alignment, [BamReadS, :int], :void
  
  # (Not documented)
  # 
  # @method bam_read_set_failed_quality_control(bam_read_s, int)
  # @param [BamReadS] bam_read_s 
  # @param [Integer] int 
  # @return [nil] 
  # @scope class
  attach_function :bam_read_set_failed_quality_control, :bam_read_set_failed_quality_control, [BamReadS, :int], :void
  
  # (Not documented)
  # 
  # @method bam_read_set_is_duplicate(bam_read_s, int)
  # @param [BamReadS] bam_read_s 
  # @param [Integer] int 
  # @return [nil] 
  # @scope class
  attach_function :bam_read_set_is_duplicate, :bam_read_set_is_duplicate, [BamReadS, :int], :void
  
  # -------- Accessing read tags --------
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:tag_type_id).</em>
  # 
  # === Options:
  # :uint8 ::
  #   
  # :uint16 ::
  #   
  # :uint32 ::
  #   
  # :int8 ::
  #   
  # :int16 ::
  #   
  # :int32 ::
  #   
  # :float ::
  #   
  # :char ::
  #   
  # :uint8_array ::
  #   
  # :uint16_array ::
  #   
  # :uint32_array ::
  #   
  # :int8_array ::
  #   
  # :int16_array ::
  #   
  # :int32_array ::
  #   
  # :float_array ::
  #   
  # :string ::
  #   
  # :hex_string ::
  #   
  # :null ::
  #   should be treated same as string
  # 
  # @method _enum_tag_type_id_
  # @return [Symbol]
  # @scope class
  enum :tag_type_id, [
    :uint8, 32,
    :uint16, 64,
    :uint32, 128,
    :int8, 48,
    :int16, 80,
    :int32, 144,
    :float, 136,
    :char, 36,
    :uint8_array, 33,
    :uint16_array, 65,
    :uint32_array, 129,
    :int8_array, 49,
    :int16_array, 81,
    :int32_array, 145,
    :float_array, 137,
    :string, 37,
    :hex_string, 45,
    :null, 2
  ]
  
  # In order to get the tag value, first get the type of the tag.
  #    Then call the corresponding function.
  #    (tag_name length must be 2 - check that in the target language)
  # 
  # @method bam_read_tag_type_id(bam_read_s, tag_name)
  # @param [BamReadS] bam_read_s 
  # @param [String] tag_name 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_tag_type_id, :bam_read_tag_type_id, [BamReadS, :string], :uchar
  
  # (Not documented)
  # 
  # @method bam_read_char_tag(bam_read_s, string)
  # @param [BamReadS] bam_read_s 
  # @param [String] string 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_char_tag, :bam_read_char_tag, [BamReadS, :string], :char
  
  # (Not documented)
  # 
  # @method bam_read_int8_tag(bam_read_s, string)
  # @param [BamReadS] bam_read_s 
  # @param [String] string 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_int8_tag, :bam_read_int8_tag, [BamReadS, :string], :char
  
  # (Not documented)
  # 
  # @method bam_read_uint8_tag(bam_read_s, string)
  # @param [BamReadS] bam_read_s 
  # @param [String] string 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_uint8_tag, :bam_read_uint8_tag, [BamReadS, :string], :uchar
  
  # (Not documented)
  # 
  # @method bam_read_int16_tag(bam_read_s, string)
  # @param [BamReadS] bam_read_s 
  # @param [String] string 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_int16_tag, :bam_read_int16_tag, [BamReadS, :string], :short
  
  # (Not documented)
  # 
  # @method bam_read_uint16_tag(bam_read_s, string)
  # @param [BamReadS] bam_read_s 
  # @param [String] string 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_uint16_tag, :bam_read_uint16_tag, [BamReadS, :string], :ushort
  
  # (Not documented)
  # 
  # @method bam_read_int32_tag(bam_read_s, string)
  # @param [BamReadS] bam_read_s 
  # @param [String] string 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_int32_tag, :bam_read_int32_tag, [BamReadS, :string], :int
  
  # (Not documented)
  # 
  # @method bam_read_uint32_tag(bam_read_s, string)
  # @param [BamReadS] bam_read_s 
  # @param [String] string 
  # @return [Integer] 
  # @scope class
  attach_function :bam_read_uint32_tag, :bam_read_uint32_tag, [BamReadS, :string], :uint
  
  # (Not documented)
  # 
  # @method bam_read_float_tag(bam_read_s, string)
  # @param [BamReadS] bam_read_s 
  # @param [String] string 
  # @return [Float] 
  # @scope class
  attach_function :bam_read_float_tag, :bam_read_float_tag, [BamReadS, :string], :float
  
  # (Not documented)
  # 
  # @method bam_read_int8_array_tag(bam_read_s, string)
  # @param [BamReadS] bam_read_s 
  # @param [String] string 
  # @return [Aint8S] 
  # @scope class
  attach_function :bam_read_int8_array_tag, :bam_read_int8_array_tag, [BamReadS, :string], Aint8S.by_value
  
  # (Not documented)
  # 
  # @method bam_read_uint8_array_tag(bam_read_s, string)
  # @param [BamReadS] bam_read_s 
  # @param [String] string 
  # @return [Auint8S] 
  # @scope class
  attach_function :bam_read_uint8_array_tag, :bam_read_uint8_array_tag, [BamReadS, :string], Auint8S.by_value
  
  # (Not documented)
  # 
  # @method bam_read_int16_array_tag(bam_read_s, string)
  # @param [BamReadS] bam_read_s 
  # @param [String] string 
  # @return [Aint16S] 
  # @scope class
  attach_function :bam_read_int16_array_tag, :bam_read_int16_array_tag, [BamReadS, :string], Aint16S.by_value
  
  # (Not documented)
  # 
  # @method bam_read_uint16_array_tag(bam_read_s, string)
  # @param [BamReadS] bam_read_s 
  # @param [String] string 
  # @return [Auint16S] 
  # @scope class
  attach_function :bam_read_uint16_array_tag, :bam_read_uint16_array_tag, [BamReadS, :string], Auint16S.by_value
  
  # (Not documented)
  # 
  # @method bam_read_int32_array_tag(bam_read_s, string)
  # @param [BamReadS] bam_read_s 
  # @param [String] string 
  # @return [Aint32S] 
  # @scope class
  attach_function :bam_read_int32_array_tag, :bam_read_int32_array_tag, [BamReadS, :string], Aint32S.by_value
  
  # (Not documented)
  # 
  # @method bam_read_uint32_array_tag(bam_read_s, string)
  # @param [BamReadS] bam_read_s 
  # @param [String] string 
  # @return [Auint32S] 
  # @scope class
  attach_function :bam_read_uint32_array_tag, :bam_read_uint32_array_tag, [BamReadS, :string], Auint32S.by_value
  
  # (Not documented)
  # 
  # @method bam_read_float_array_tag(bam_read_s, string)
  # @param [BamReadS] bam_read_s 
  # @param [String] string 
  # @return [AfloatS] 
  # @scope class
  attach_function :bam_read_float_array_tag, :bam_read_float_array_tag, [BamReadS, :string], AfloatS.by_value
  
  # (Not documented)
  # 
  # @method bam_read_string_tag(bam_read_s, string)
  # @param [BamReadS] bam_read_s 
  # @param [String] string 
  # @return [DstringS] 
  # @scope class
  attach_function :bam_read_string_tag, :bam_read_string_tag, [BamReadS, :string], DstringS.by_value
  
  # The following functions return a structure with updated 'buf' and 'len'.
  #    If the pointer is different from the initial 'buf' field of the read,
  #    the data from the buffer must be copied into newly allocated memory. 
  #    Otherwise only the length must be updated.
  # 
  # @method df_bam_read_set_char_tag(bam_read_s, string, char_s)
  # @param [BamReadS] bam_read_s 
  # @param [String] string 
  # @param [Integer] char_s 
  # @return [BufferS] 
  # @scope class
  attach_function :df_bam_read_set_char_tag, :df_bam_read_set_char_tag, [BamReadS, :string, :char], BufferS
  
  # (Not documented)
  # 
  # @method df_bam_read_set_int8_tag(bam_read_s, string, s_char)
  # @param [BamReadS] bam_read_s 
  # @param [String] string 
  # @param [Integer] s_char 
  # @return [BufferS] 
  # @scope class
  attach_function :df_bam_read_set_int8_tag, :df_bam_read_set_int8_tag, [BamReadS, :string, :char], BufferS
  
  # (Not documented)
  # 
  # @method df_bam_read_set_uint8_tag(bam_read_s, string, u_char)
  # @param [BamReadS] bam_read_s 
  # @param [String] string 
  # @param [Integer] u_char 
  # @return [BufferS] 
  # @scope class
  attach_function :df_bam_read_set_uint8_tag, :df_bam_read_set_uint8_tag, [BamReadS, :string, :uchar], BufferS
  
  # (Not documented)
  # 
  # @method df_bam_read_set_int16_tag(bam_read_s, string, short)
  # @param [BamReadS] bam_read_s 
  # @param [String] string 
  # @param [Integer] short 
  # @return [BufferS] 
  # @scope class
  attach_function :df_bam_read_set_int16_tag, :df_bam_read_set_int16_tag, [BamReadS, :string, :short], BufferS
  
  # (Not documented)
  # 
  # @method df_bam_read_set_uint16_tag(bam_read_s, string, u_short)
  # @param [BamReadS] bam_read_s 
  # @param [String] string 
  # @param [Integer] u_short 
  # @return [BufferS] 
  # @scope class
  attach_function :df_bam_read_set_uint16_tag, :df_bam_read_set_uint16_tag, [BamReadS, :string, :ushort], BufferS
  
  # (Not documented)
  # 
  # @method df_bam_read_set_int32_tag(bam_read_s, string, int)
  # @param [BamReadS] bam_read_s 
  # @param [String] string 
  # @param [Integer] int 
  # @return [BufferS] 
  # @scope class
  attach_function :df_bam_read_set_int32_tag, :df_bam_read_set_int32_tag, [BamReadS, :string, :int], BufferS
  
  # (Not documented)
  # 
  # @method df_bam_read_set_uint32_tag(bam_read_s, string, u_int)
  # @param [BamReadS] bam_read_s 
  # @param [String] string 
  # @param [Integer] u_int 
  # @return [BufferS] 
  # @scope class
  attach_function :df_bam_read_set_uint32_tag, :df_bam_read_set_uint32_tag, [BamReadS, :string, :uint], BufferS
  
  # (Not documented)
  # 
  # @method df_bam_read_set_float_tag(bam_read_s, string, float)
  # @param [BamReadS] bam_read_s 
  # @param [String] string 
  # @param [Float] float 
  # @return [BufferS] 
  # @scope class
  attach_function :df_bam_read_set_float_tag, :df_bam_read_set_float_tag, [BamReadS, :string, :float], BufferS
  
  # (Not documented)
  # 
  # @method df_bam_read_set_string_tag(bam_read_s, string, strz)
  # @param [BamReadS] bam_read_s 
  # @param [String] string 
  # @param [String] strz 
  # @return [BufferS] 
  # @scope class
  attach_function :df_bam_read_set_string_tag, :df_bam_read_set_string_tag, [BamReadS, :string, :string], BufferS
  
  # notice that pileup_read_t can be passed as an argument
  #    to all functions that expect bam_read_t
  # 
  # = Fields:
  # :read ::
  #   (BamReadS) 
  # :additional_info ::
  #   (Array<Integer>) 
  class PileupReadS < FFI::Struct
    layout :read, BamReadS.by_value,
           :additional_info, [:int, 5]
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :buf ::
  #   (PileupReadS) 
  # :len ::
  #   (Integer) 
  class ApileupReadS < FFI::Struct
    layout :buf, PileupReadS,
           :len, :ulong
  end
  
  # CIGAR operations after the current one
  # 
  # @method bam_pileup_read_cigar_before(pileup_read_s)
  # @param [PileupReadS] pileup_read_s 
  # @return [CigarS] 
  # @scope class
  attach_function :bam_pileup_read_cigar_before, :bam_pileup_read_cigar_before, [PileupReadS], CigarS.by_value
  
  # CIGAR operations before the current one
  # 
  # @method bam_pileup_read_cigar_after(pileup_read_s)
  # @param [PileupReadS] pileup_read_s 
  # @return [CigarS] 
  # @scope class
  attach_function :bam_pileup_read_cigar_after, :bam_pileup_read_cigar_after, [PileupReadS], CigarS.by_value
  
  # current CIGAR operation
  # 
  # @method bam_pileup_read_cigar_operation(pileup_read_s)
  # @param [PileupReadS] pileup_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_pileup_read_cigar_operation, :bam_pileup_read_cigar_operation, [PileupReadS], :uint
  
  # how many bases were consumed from the current CIGAR operation
  # 
  # @method bam_pileup_read_cigar_operation_offset(pileup_read_s)
  # @param [PileupReadS] pileup_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_pileup_read_cigar_operation_offset, :bam_pileup_read_cigar_operation_offset, [PileupReadS], :uint
  
  # how many bases were consumed from the query sequence
  # 
  # @method bam_pileup_read_query_offset(pileup_read_s)
  # @param [PileupReadS] pileup_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_pileup_read_query_offset, :bam_pileup_read_query_offset, [PileupReadS], :int
  
  # current base
  # 
  # @method bam_pileup_read_current_base(pileup_read_s)
  # @param [PileupReadS] pileup_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_pileup_read_current_base, :bam_pileup_read_current_base, [PileupReadS], :char
  
  # current base quality (-1 if deletion)
  # 
  # @method bam_pileup_read_current_base_quality(pileup_read_s)
  # @param [PileupReadS] pileup_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_pileup_read_current_base_quality, :bam_pileup_read_current_base_quality, [PileupReadS], :char
  
  # Create a pileup engine.
  #    The reads must be coordinate-sorted (can be from different references),
  #    unmapped ones will be skipped automatically.
  #    If use_md is true, MD tag will be used to get reference bases.
  #    If skip_zeros is true, columns with zero coverage will be skipped.
  # 
  # @method bam_pileup_new(bam_read_range_t, use_md, skip_zeros)
  # @param [FFI::Pointer(BamReadRangeT)] bam_read_range_t 
  # @param [Integer] use_md 
  # @param [Integer] skip_zeros 
  # @return [FFI::Pointer(PileupT)] 
  # @scope class
  attach_function :bam_pileup_new, :bam_pileup_new, [:pointer, :int, :int], :pointer
  
  # Proceed to the next pileup column.
  #    The interface is a bit weird: you should tell the function
  #    whether you call it the first time on the pileup or not
  #    (otherwise, the first column will be skipped).
  #    This allows to move to the next column in a single FFI call.
  #    The returned value of NULL means that all columns are processed.
  # 
  # @method bam_pileup_next(pileup_t, it_wasnt_first_call)
  # @param [FFI::Pointer(PileupT)] pileup_t 
  # @param [Integer] it_wasnt_first_call 
  # @return [FFI::Pointer(PileupColumnT)] 
  # @scope class
  attach_function :bam_pileup_next, :bam_pileup_next, [:pointer, :int], :pointer
  
  # reference ID
  # 
  # @method bam_pileup_column_ref_id(pileup_column_t)
  # @param [FFI::Pointer(PileupColumnT)] pileup_column_t 
  # @return [Integer] 
  # @scope class
  attach_function :bam_pileup_column_ref_id, :bam_pileup_column_ref_id, [:pointer], :int
  
  # current reference base (always 'N' if use_md wasn't specified)
  # 
  # @method bam_pileup_column_ref_base(pileup_column_t)
  # @param [FFI::Pointer(PileupColumnT)] pileup_column_t 
  # @return [Integer] 
  # @scope class
  attach_function :bam_pileup_column_ref_base, :bam_pileup_column_ref_base, [:pointer], :char
  
  # array of reads overlapping current column
  # 
  # @method bam_pileup_column_reads(pileup_column_t)
  # @param [FFI::Pointer(PileupColumnT)] pileup_column_t 
  # @return [ApileupReadS] 
  # @scope class
  attach_function :bam_pileup_column_reads, :bam_pileup_column_reads, [:pointer], ApileupReadS.by_value
  
  # coverage at the site
  # 
  # @method bam_pileup_column_coverage(pileup_column_t)
  # @param [FFI::Pointer(PileupColumnT)] pileup_column_t 
  # @return [Integer] 
  # @scope class
  attach_function :bam_pileup_column_coverage, :bam_pileup_column_coverage, [:pointer], :ulong
  
  # zero-based position on the reference
  # 
  # @method bam_pileup_column_position(pileup_column_t)
  # @param [FFI::Pointer(PileupColumnT)] pileup_column_t 
  # @return [Integer] 
  # @scope class
  attach_function :bam_pileup_column_position, :bam_pileup_column_position, [:pointer], :ulong
  
  # bases ('-' stay for deletions), length is equal to coverage
  # 
  # @method f_bam_pileup_column_bases(pileup_column_t)
  # @param [FFI::Pointer(PileupColumnT)] pileup_column_t 
  # @return [String] 
  # @scope class
  attach_function :f_bam_pileup_column_bases, :f_bam_pileup_column_bases, [:pointer], :string
  
  # base qualities (-1 on deletions)
  # 
  # @method f_bam_pileup_column_base_quals(pileup_column_t)
  # @param [FFI::Pointer(PileupColumnT)] pileup_column_t 
  # @return [Aint8S] 
  # @scope class
  attach_function :f_bam_pileup_column_base_quals, :f_bam_pileup_column_base_quals, [:pointer], Aint8S.by_value
  
  # default compression level is -1, the number can be in range -1 .. 9;
  #    BAM magic is automatically written during the construction;
  #    NULL return value indicates that an exception has occurred.
  # 
  # @method bam_writer_new(filename, compression_level)
  # @param [String] filename 
  # @param [Integer] compression_level 
  # @return [FFI::Pointer(BamWriterT)] 
  # @scope class
  attach_function :bam_writer_new, :bam_writer_new, [:string, :int], :pointer
  
  # (Not documented)
  # 
  # @method bam_writer_new2(filename, int, task_pool_t)
  # @param [String] filename 
  # @param [Integer] int 
  # @param [FFI::Pointer(TaskPoolT)] task_pool_t 
  # @return [FFI::Pointer(BamWriterT)] 
  # @scope class
  attach_function :bam_writer_new2, :bam_writer_new2, [:string, :int, :pointer], :pointer
  
  # next step after construction is to write SAM header
  # 
  # @method bam_writer_push_header(bam_writer_t, sam_header_t)
  # @param [FFI::Pointer(BamWriterT)] bam_writer_t 
  # @param [FFI::Pointer(SamHeaderT)] sam_header_t 
  # @return [Integer] 
  # @scope class
  attach_function :bam_writer_push_header, :bam_writer_push_header, [:pointer, :pointer], :int
  
  # then reference sequence information follows
  # 
  # @method bam_writer_push_ref_info(bam_writer_t, refs, nrefs)
  # @param [FFI::Pointer(BamWriterT)] bam_writer_t 
  # @param [ReferenceInfoS] refs 
  # @param [Integer] nrefs 
  # @return [Integer] 
  # @scope class
  attach_function :bam_writer_push_ref_info, :bam_writer_push_ref_info, [:pointer, ReferenceInfoS, :ulong], :int
  
  # and then reads
  # 
  # @method bam_writer_push_read(bam_writer_t, bam_read_s)
  # @param [FFI::Pointer(BamWriterT)] bam_writer_t 
  # @param [BamReadS] bam_read_s 
  # @return [Integer] 
  # @scope class
  attach_function :bam_writer_push_read, :bam_writer_push_read, [:pointer, BamReadS], :int
  
  # don't forget to close the stream! This also adds BGZF EOF block.
  # 
  # @method bam_writer_close(bam_writer_t)
  # @param [FFI::Pointer(BamWriterT)] bam_writer_t 
  # @return [Integer] 
  # @scope class
  attach_function :bam_writer_close, :bam_writer_close, [:pointer], :int
  
  # flushes current BGZF block; may be useful in some cases
  # 
  # @method bam_writer_flush(bam_writer_t)
  # @param [FFI::Pointer(BamWriterT)] bam_writer_t 
  # @return [Integer] 
  # @scope class
  attach_function :bam_writer_flush, :bam_writer_flush, [:pointer], :int
  
end
